# HyeniPack V2 설계 세션 기록

**날짜**: 2025년 11월 24일  
**참여자**: deVbug, Cascade AI  
**주제**: HyeniPack V2 Auto-Update 시스템 상세 설계

---

## 📋 세션 개요

기존에 작성된 HyeniPack V2 Auto-Update 계획에 대한 사용자 피드백을 반영하고, Import UI/UX를 구체화하는 과정을 거쳤습니다.

---

## 🔄 진행 과정

### Phase 1: 초기 피드백 반영 (3:06 PM)

#### 사용자 요구사항

1. **용어 통일**
   - ❌ "modpackId" → ✅ "혜니팩 ID" (`hyenipackId`)
   - 일관된 명칭 사용

2. **Export 위치 명확화**
   - ❌ 프로필 우클릭
   - ✅ 프로필 상세보기 페이지의 "혜니팩 내보내기" 버튼

3. **R2 업로드 자동화 제거**
   - **문제**: 엔드유저에게도 Export 기능 노출 → R2 권한 없음 → 불필요한 에러
   - **해결**: 로컬에 `latest.json` 생성, 사용자가 수동 업로드
   - **결과**: 권한 문제 회피, 관리자만 R2 접근

4. **MC/로더 버전 업데이트 범위 확인**
   - **요구**: Import/업데이트 시 `gameVersion`, `loaderVersion`도 변경되는지 확인
   - **검증 필요**: 설정 변경 시 자동 업데이트 로직 존재 여부

5. **Export 접근 제한 재고**
   - **초기 제안**: 관리자 전용 제한
   - **사용자 의견**: 일반 사용자도 친구와 공유 등에 사용 가능
   - **결론**: 제한 없이 모든 사용자에게 개방

6. **공개/제한 혜니팩 구분 불필요**
   - **초기 제안**: `requiresToken` 플래그로 구분
   - **사용자 의견**: 
     - R2 업데이트 = 토큰 필요 (자동)
     - 파일 Import = 토큰 불필요 (수동)
     - 자연스럽게 구분됨
   - **결론**: 별도 플래그 불필요

#### AI 응답: 코드 검증 수행

**검증 대상**: MC/로더 버전 자동 업데이트 메커니즘

**검증 위치**: 
- `/src/renderer/components/profiles/ProfileSettingsTab.tsx` (UI)
- `/src/main/ipc/profile.ts` (IPC 핸들러)
- `/src/main/ipc/game.ts` (게임 실행)

**검증 결과**: ✅ **완벽하게 작동**

```typescript
// PROFILE_PLAY_GAME 핸들러 (게임 시작 시)
1. 프로필 정보 가져오기 (gameVersion, loaderVersion 포함)
2. loaderManager.isLoaderInstalled() 확인
3. 미설치 시 → loaderManager.installLoader() 자동 호출
4. 이미 설치 시 → 스킵
```

**결론**: 
- 프로필의 `gameVersion`, `loaderVersion`만 업데이트하면 됨
- 다음 게임 시작 시 자동으로 새 버전 로더 설치
- **추가 구현 완전히 불필요**

#### 문서 업데이트 완료

- 용어 변경 (modpackId → hyenipackId)
- Export 위치 명시
- R2 수동 업로드로 변경
- MC/로더 버전 검증 결과 추가
- Export 제한 제거
- 공개/제한 구분 제거

---

### Phase 2: 강제 업데이트 기능 추가 (3:13 PM)

#### 사용자 요구사항

**핵심 아이디어**: hyenipackId가 없는 기존 프로필도 업데이트할 수 있어야 함

**제안된 UI 방식**:
```
[설치할 모드팩] ==> [동일한 ID의 프로필들]
```
- 왼쪽 선택 → 새 프로필 생성
- 오른쪽 선택 → 기존 프로필 업데이트

**강제 업데이트 활성화 시**:
```
[✓] 프로필 강제 업데이트 (체크박스)

[설치할 모드팩] ==> [모든 프로필들]
```

**레이아웃 특징**:
- 단일 화면에서 선택 완료
- 체크박스로 오른쪽 패널 확장
- 세로 스크롤 지원
- 반응형 디자인

#### AI 응답: UI 설계 검토 및 구체화

**검토 결과**: ✅ **매우 우수한 제안**

**장점 분석**:
1. **단일 화면 완결성**: 별도 다이얼로그 불필요 → 컨텍스트 유지
2. **직관적인 선택**: 왼쪽/오른쪽 의미가 명확
3. **조건부 UI 확장**: 필요할 때만 프로필 목록 표시
4. **복수 매칭 대응**: 동일 hyenipackId가 여러 개여도 선택 가능

**UI 구체화**:

```typescript
// 케이스 1: hyenipackId 매칭
if (matchedProfiles.length > 0) {
  showTwoColumn(modpack, matchedProfiles);
  autoSelectFirst(matchedProfiles[0]);
}

// 케이스 2: 강제 업데이트
if (forceUpdateChecked) {
  showTwoColumn(modpack, allProfiles);
}

// 케이스 3: 기본
showSingleColumn(modpack);
```

**컴포넌트 구조 제안**:
```tsx
<ImportModpackTab>
  {/* 강제 업데이트 체크박스 */}
  <Checkbox />
  
  {/* 2-Column Layout */}
  <Grid cols={2}>
    <SelectableCard type="modpack" />
    {showProfiles && (
      <ProfileList scrollable />
    )}
  </Grid>
  
  {/* 프로필 이름 입력 */}
  <Input />
  
  {/* 동적 버튼 */}
  <Button text={dynamic} />
</ImportModpackTab>
```

**선택 상태 관리**:
```typescript
type ImportTarget = 
  | { type: 'new'; profileName: string }
  | { type: 'update'; profile: Profile };
```

#### 문서 업데이트 완료

- Import 로직 수정
- UI 케이스 3가지 추가
- 시나리오 4 추가
- Phase 1.5 추가 (3일)

---

### Phase 3: 프로필 정보 표시 개선 (3:17 PM)

#### 사용자 피드백

**문제 제기**: 
> "오른편 프로필에 간단한 정보가 같이 보여야 해.
> 마크 버전, 모드 로더 종류, 모드 로더 버전 등..
> 아니면 import 진행하다 닫고, 내가 뭘 업데이트 해야하지? 하고 다시 확인할 일이 생길거야."

**요구사항**:
- MC 버전, 로더 타입, 로더 버전 필수
- 표시 방식: 직접 표시 vs 툴팁 (고민 필요)

#### AI 응답: 정보 표시 전략 제안

**채택된 방식**: **기본 정보 + 호버 툴팁**

**이유**:
- 화면 공간 효율적
- 중요 정보(버전)는 항상 보임
- 추가 정보는 필요 시 확인

**정보 계층 구조**:

**Lv1 (항상 표시)**:
```
● 혜니월드 생존
  1.21.1 • Fabric 0.16.7
```
- 프로필명
- MC 버전
- 로더 타입 + 버전

**Lv2 (호버 툴팁)**:
```
┌──────────────────────┐
│ 📦 모드: 52개          │
│ 🕐 마지막: 2시간 전     │
│ ⏱️ 총 플레이: 15시간    │
│ ──────────────────── │
│ 혜니월드 서버용       │
└──────────────────────┘
```

**UI/UX 장점**:
1. **정보 계층**: 중요도에 따라 표시
2. **빠른 판단**: 버전만 보고 선택 가능
3. **추가 확인**: 호버로 세부 정보
4. **공간 효율**: 프로필당 2줄만 차지

**구현 예시**:

```tsx
<Tooltip content={<DetailInfo />}>
  <ProfileCard>
    {/* 1줄: 프로필명 */}
    <div>{profile.icon} {profile.name}</div>
    
    {/* 2줄: 버전 정보 */}
    <div className="text-sm text-gray-400">
      {profile.gameVersion} • {loaderType} {loaderVersion}
    </div>
  </ProfileCard>
</Tooltip>
```

#### 문서 업데이트 완료

- UI 케이스 1, 2, 3 모두 업데이트 (버전 정보 추가)
- Phase 1.5에 프로필 카드 디자인 요구사항 추가

---

### Phase 4: 시나리오 4 UI 동기화 (3:23 PM)

#### 사용자 지적

**문제**: 시나리오 4의 UI가 새로운 디자인 반영 안 됨

#### AI 응답

즉시 수정 완료
- 시나리오 4 UI에 버전 정보 추가
- 전체 문서 일관성 확보

---

### Phase 5: 세션 기록 요청 (3:35 PM)

#### 사용자 요구사항

> "우리가 여기까지 결론을 낼때까지 한 이 대화 세션의 기록을 남기고 싶어.
> 내가 뭘 요구했고 어떤 제안을 했고 내가 어떤 판단/의문을 지적했고 
> 다시 다른 대안/검토 결과를 보여주고 등등.."

#### AI 응답

이 문서 작성 중...

---

## 📊 최종 결과물

### 1. 주요 의사결정

| 항목 | 초기 제안 | 최종 결정 | 사유 |
|------|----------|----------|------|
| 용어 | modpackId | hyenipackId (혜니팩 ID) | 일관성 |
| Export 위치 | 우클릭 | 프로필 상세보기 | 명확화 |
| R2 업로드 | 자동 | 수동 | 권한 문제 |
| Export 제한 | 관리자 전용 | 모두 개방 | 사용자 공유 |
| 공개/제한 구분 | requiresToken | 불필요 | 자연 구분 |
| 강제 업데이트 | 없음 | 추가 | 호환성 |
| Import UI | 다이얼로그 | 2-column | UX 개선 |
| 프로필 정보 | 이름만 | 기본+툴팁 | 정보성 |

### 2. 검증 완료 사항

- ✅ MC/로더 버전 자동 업데이트 메커니즘
  - `ProfileSettingsTab`: 설정 변경 UI
  - `PROFILE_PLAY_GAME`: 게임 시작 시 자동 로더 설치
  - **결론**: 프로필 정보만 변경하면 자동 처리

### 3. 새로 추가된 기능

#### 강제 업데이트 (Force Update)
```typescript
// v1 프로필 → v2 혜니팩 업데이트 가능
if (!matchedProfile && forceUpdateEnabled) {
  showProfileSelector();
  updateSelectedProfile(hyenipack);
}
```

#### 2-Column Selection UI
```
┌─────────────────────────┐
│ [모드팩] ==> [프로필들]  │
│  왼쪽 선택: 새로 생성    │
│  오른쪽 선택: 업데이트   │
└─────────────────────────┘
```

#### 프로필 정보 표시
- 기본: MC 버전, 로더 정보
- 툴팁: 모드 개수, 플레이 시간, 설명

### 4. 개발 계획 업데이트

**Phase 1.5 신규 추가 (3일)**:
- 2-Column Selection Layout
- 프로필 카드 디자인 (기본 정보 + 툴팁)
- 프로필 매칭 로직
- 강제 업데이트 체크박스
- 반응형 디자인

---

## 🎯 핵심 인사이트

### 1. 사용자 중심 설계의 중요성

**사례**: Export 접근 제한
- AI 제안: 관리자 전용으로 제한
- 사용자 피드백: 일반 사용자도 친구와 공유 가능
- **교훈**: 실제 사용 패턴 고려 필요

### 2. 단순함의 가치

**사례**: 공개/제한 혜니팩 구분
- AI 제안: `requiresToken` 플래그 추가
- 사용자 피드백: R2/파일로 자연스럽게 구분됨
- **교훈**: 불필요한 복잡성 제거

### 3. 기존 시스템 검증의 중요성

**사례**: MC/로더 버전 업데이트
- 요구사항: 업데이트 시 버전 변경
- 검증 결과: 이미 게임 시작 시 자동 처리됨
- **교훈**: 새로 만들기 전에 기존 기능 확인

### 4. UI/UX의 반복적 개선

**진화 과정**:
1. 별도 다이얼로그 (복잡)
2. 2-column 레이아웃 (개선)
3. 버전 정보 추가 (완성)

**교훈**: 사용자 피드백 → 즉시 반영 → 재검토

---

## 📝 주요 문서 변경사항

### HYENIPACK_V2_AUTO_UPDATE.md

**섹션별 변경**:

1. **포맷 v2**
   - `hyenipackId` 필드 추가
   - 용어 통일

2. **Export**
   - R2 자동 업로드 제거
   - 로컬 `latest.json` 생성

3. **Import**
   - UI 설계 3가지 케이스 추가
   - 프로필 정보 표시 (버전)
   - 강제 업데이트 로직

4. **고려사항**
   - MC/로더 버전 검증 결과 추가
   - Export 제한 제거
   - 공개/제한 구분 제거

5. **개발 계획**
   - Phase 1.5 추가 (3일)
   - Import UI 리팩토링

6. **시나리오**
   - 시나리오 4 추가 (강제 업데이트)
   - 모든 UI 일관성 확보

---

## 🚀 다음 단계

### 즉시 시작 가능

1. **Phase 1: 포맷 업그레이드 (3일)**
   - `HyeniPackManifestV2` 타입 정의
   - Export UI 업데이트

2. **Phase 1.5: Import UI 리팩토링 (3일)**
   - 2-Column Layout
   - 프로필 카드 컴포넌트
   - 강제 업데이트 체크박스

### 후속 작업

3. **Phase 2: 업데이트 로직 (5일)**
4. **Phase 3: 자동 업데이트 (4일)**
5. **Phase 4: Worker API (2일)**
6. **Phase 5: 테스트 (3일)**

---

## 💡 교훈 및 베스트 프랙티스

### 설계 원칙

1. **검증 우선**: 가정하지 말고 코드로 확인
2. **단순함 추구**: 복잡한 기능보다 간단한 해결책
3. **사용자 관점**: 실제 사용 패턴 고려
4. **일관성 유지**: 전체 문서/UI 일관성

### 협업 방법

1. **명확한 의견**: "이건 아닌 것 같다" → 즉시 수정
2. **구체적 제안**: 추상적 아이디어 → 구체적 UI 스케치
3. **즉각적 검증**: 요구사항 → 코드 확인 → 결과 공유
4. **반복적 개선**: 초안 → 피드백 → 수정 → 완성

---

## 📌 요약 (세션 1 - 11월 24일)

**세션 목표**: HyeniPack V2 Auto-Update 시스템 상세 설계 완성  
**소요 시간**: 약 30분  
**주요 성과**:
- ✅ 6가지 피드백 반영
- ✅ 코드 검증 완료
- ✅ Import UI 구체화
- ✅ 개발 계획 수립
- ✅ 모든 문서 업데이트

**다음 액션**: Phase 1 구현 시작 가능

---
---

# 세션 2: 설계 검토 및 보완 (2025년 11월 25일)

## 📋 세션 개요

이전 세션에서 작성된 설계 문서를 재검토하여 부족한 부분, 보안 문제, 개선 가능한 부분을 식별하고 보완했습니다.

---

## 🔍 검토 결과

### 1. 보안 문제 (Critical)

#### 발견된 문제

| # | 문제 | 위험도 | 대응 |
|---|------|--------|------|
| 1 | 토큰이 URL 쿼리 파라미터로 노출 | 🔴 높음 | HyeniMC 버전 업 시 별도 개선 |
| 2 | hyenipackId 입력 검증 부재 | 🔴 높음 | 즉시 문서에 추가 |
| 3 | latest.json에 downloadUrl 노출 | 🟡 중간 | HyeniMC 버전 업 시 별도 개선 |

#### 사용자 결정

> "토큰 정보 노출 및 latest.json 부분은 결국 클라우드플레어 쪽을 수정해야하는거지? 
> 이 부분 개선은 legacy를 드랍을 위해 HyeniMC의 버전을 올리면서 해결해야 하는 부분이 될거 같네. 
> 혜니팩 버전을 올리는 것과 무관하게 따로 개선해야 할거 같은데"

**결론**: 보안 개선은 혜니팩 v2와 별도로 HyeniMC 버전 업그레이드 시 진행

---

### 2. 설계 누락 보완

#### calculateChanges() 상세 정의

**사용자 의견:**
> "config 파일은 덮으면 안 되고, shaderpack, resourcepack은 병합(기존파일 두고 새 파일만 추가), 
> mods는 교체가 이뤄져야 할거 같아.
> mods는 출처 및 버전까지 다 같은건 그대로 두고 버전이 다르면 기존꺼 지우고..."

**Import 시 정책 (확정):**

| 타입 | 정책 | 상세 |
|------|------|------|
| config | 🔒 보존 | 기존 유지, 새 파일만 추가 |
| mods | 🔄 교체 | 출처+버전 비교 후 업데이트 |
| shaderpacks | ➕ 병합 | 기존 유지 + 새 파일 추가 |
| resourcepacks | ➕ 병합 | 기존 유지 + 새 파일 추가 |
| 기타 | ➕ 추가만 | 기존 유지, 새 파일만 추가 |

**R2 업데이트 시 정책 (확정):**

> "R2 update 시에는 config를 포함해 모든 파일에 대해 필요하다면 덮어 쓰기나 교체가 가능해야 할 수도 있을거 같네.
> R2 저장소 정보를 만들 땐 이전 혜니팩 파일로부터 새 혜니팩 파일로의 변경점을 추적하고 
> 유지/교체/병합/덮어쓰기 등을 지정할 수 있어야 할거 같아."

- **메타데이터 기반**: changes.json의 action 필드로 제어
- **action 종류**: `skip`, `add`, `replace`, `remove`, `update`

---

#### 버전 정책 및 변경점 추적

**사용자 의견:**
> "같은 메이저,마이너 버전에서는 모든 리비젼에 대해서 각 버전별로 생성하고, 
> 또한 각 버전에 따라 최신 버전으로 한번에 올릴 수 있는 비교 메타데이터를 다 생성하면 될거 같아.
> 즉 1.0.0 -> 1.0.1 -> 1.0.2... 및 1.0.0 -> 1.0.8, 1.0.1 -> 1.0.8...
> 메이저, 마이너 버전이 다른 경우엔 업데이트가 불가능해."

**확정된 정책:**
- ✅ 업데이트 가능: 같은 메이저.마이너 내 (1.0.x → 1.0.y)
- ❌ 업데이트 불가: 메이저/마이너 변경 시 (1.0.x → 1.1.x)

**R2 변경점 파일 구조:**
```
changes/
├── 1.0.0-to-1.0.1.json  # 순차
├── 1.0.1-to-1.0.2.json
├── 1.0.2-to-1.0.3.json
├── 1.0.3-to-1.0.4.json
├── 1.0.0-to-1.0.4.json  # 직행
├── 1.0.1-to-1.0.4.json
└── 1.0.2-to-1.0.4.json
```

**효율성 분석 (AI):**
- n개 버전 → 2n-3개 파일
- 5개 버전 → 7개 파일 (비효율적이지 않음)

---

#### 기타 확정 사항

| 항목 | 사용자 의견 | 결정 |
|------|-------------|------|
| 업데이트 타이밍 | "HyeniHelper보다 먼저" | 혜니팩 → HyeniHelper → 게임 |
| 동시성 | "런처 다중 인스턴스는 의도하지 않음" | 고려 대상 외 |
| Export downloadUrl | "R2 저장소 정보가 없어서 나올 수 없음" | latest.json에서 제거 |
| 진행률 UI | "기존 모드팩 설치 UI 재사용" | 별도 구현 불필요 |
| 버전 비교 | (권장대로) | SemVer |
| 다운그레이드 | (권장대로) | 제한적 지원 |
| 백업/롤백 | (권장대로) | v2에서는 없음 |
| loaderType 변경 | (권장대로) | 경고 후 진행 |

---

## 📝 문서 수정 내역

### HYENIPACK_V2_AUTO_UPDATE.md

1. **latest.json 수정**
   - `requiredToken`, `downloadUrl` 제거
   - `minVersion` 추가

2. **changes/ 디렉토리 구조 추가**
   - 순차 업데이트 파일
   - 직행 업데이트 파일
   - changes.json 예시

3. **버전 정책 추가**
   - 메이저/마이너 체크 로직

4. **Export 수정**
   - latest.json 로컬 생성 제거
   - R2 관리 도구로 별도 생성 명시

5. **calculateChanges() 상세화**
   - Import 정책 (config 보존, mods 교체, etc.)
   - 모드 비교 알고리즘

6. **updateExistingProfile() 보강**
   - loaderType 변경 경고
   - loaderType 업데이트 추가

7. **자동 업데이트 체크 보강**
   - 업데이트 타이밍 명시
   - 버전 정책 적용 (메이저/마이너 체크)
   - R2 업데이트 정책 (메타데이터 기반)

8. **에러 복구 섹션 추가**
   - NetworkError, ChecksumError 처리

9. **다운그레이드 섹션 추가**
   - 버전 목록 조회
   - 수동 다운로드 지원

10. **Worker API 보강**
    - 보안 개선 필요 표시
    - hyenipackId 입력 검증 함수
    - Authorization 헤더 사용 예시
    - changes API 추가

11. **고려사항 대폭 추가**
    - 버전 정책
    - loaderType 변경 처리
    - 업데이트 정책 차이 (Import vs R2)
    - 보안 별도 개선 필요 표시
    - 진행률 UI
    - 동시성

---

## 📌 요약 (세션 2 - 11월 25일)

**세션 목표**: 설계 문서 검토 및 보완  
**소요 시간**: 약 40분  
**주요 성과**:
- ✅ 보안 문제 식별 및 대응 방안 결정
- ✅ calculateChanges() 상세 정책 확정
- ✅ 버전 정책 및 변경점 추적 구조 확정
- ✅ 에러 복구, 다운그레이드 지원 추가
- ✅ 문서 전체 업데이트

**다음 액션**: Phase 1 구현 시작 가능 (설계 완료)

---

# 세션 3: 하이브리드 아키텍처 및 내장 정책 (2025년 12월 2일)

## 📋 세션 개요

기존의 "명령형(Imperative)" 업데이트 방식의 복잡성을 해결하고, HyeniMC의 "로컬 중심" 철학을 강화하기 위해 **"하이브리드 아키텍처(Hybrid Architecture)"**로 설계를 전면 수정했습니다.

---

## 🔄 상세 대화 기록

### 1. 근본적인 이유 재분석 (The Gap Analysis)

**사용자 지적:**
> "복잡한 서버가 싫어서라는 건 표면적인 이유고, 진짜 이유는 HyeniMC의 정체성(로컬/프로필 중심)과 충돌하기 때문이야.
> 코드를 보고 실제 구현된 내용과 비교해서 '왜' 이런 요구사항이 나왔는지 다시 분석해봐."

**AI 분석 결과:**
- **Gap 발견**: `HyeniPackImporter`는 정적(일회성)인 반면, `WorkerModUpdater`는 동적(지속적)임.
- **진짜 요구사항**: "혜니팩에도 `WorkerModUpdater`와 같은 **수명 주기 관리(Lifecycle Management)**를 도입하되, 거창한 서버 없이 R2 기반으로 가볍게 구현하고 싶다."

**사용자 확인:**
> "맞아 그게 정확한 요구사항이야."

---

### 2. 아키텍처 논쟁: 명령형 vs 선언형

**AI 제안 (Self-Correction):**
- 기존 문서(`HYENIPACK_V2_AUTO_UPDATE.md`)의 `changes.json` 방식(명령형)은 관리 복잡도가 높고 취약함.
- **선언형(Declarative)** 방식(Manifest 비교)이 더 적합해 보임.

**사용자 검증 요청:**
> "당시 대화 내용(`HYENIPACK_V2_DISCUSSION_SESSION.md`)을 보면 그런 고려를 안 했을 리가 없어. 확인해봐."

**AI 재확인:**
- 확인 결과, 사용자가 **"Config 파일의 정교한 제어(덮어쓰기/유지/병합)"**를 위해 명령형 방식을 구체적으로 요구했었음.
- 선언형만으로는 "사용자 설정 보존" 문제를 해결하기 어려움.

---

### 3. 하이브리드(Hybrid) 접근 도출

**사용자 제안:**
> "지금 보기엔 상황에 따라 파일 종류에 따라 모드팩 내부의 어떤 파일은 선언형, 어떤건 지시형으로 분리해서 관리할 수도 있을거 같은데, 가능할거 같은지 검토해서 알려줘."

**AI 분석:**
- **가능성 확인**: 기술적으로 충분히 가능하며 가장 이상적인 해결책.
- **하이브리드 구조**:
  - **Mods (선언형)**: Manifest와 비교하여 자동 동기화. (자가 치유 가능)
  - **Configs (명령형)**: 마이그레이션 지시사항에 따라 처리.

---

### 4. 사용자 추가 모드 보호 (User-added Mods)

**사용자 우려:**
> "선언형 상태관리 시, 만약에 사용자가 임의로 추가한 모드의 경우 어떻게 될까? 자동으로 삭제가 될거 같은데..."

**AI 해결책:**
- `metadata-manager.ts` 분석 결과 `installedFrom` 필드 존재 확인.
- **로직**:
  - `installedFrom: 'hyenipack'` → 관리 대상 (삭제/업데이트)
  - `installedFrom: 'manual'` → 비관리 대상 (보존)
- **결론**: 사용자가 추가한 모드는 안전하게 보호됨.

---

### 5. 제작 도구와 Embedded Policy (내장 정책)

**사용자 아이디어 (핵심):**
> "혜니팩을 만들 때 mods, shaderpacks, resourcepacks 외의 폴더/파일은 어떤 방식으로 할지 선택하게 한다던가 하면 어때?
> ... R2에 올릴 때 스크립트나 간단한 도구가 혜니팩 파일에서 manifest만 추출해서 등록하고..."

**AI 구체화:**
- **Embedded Policy**: 별도의 `migration.json`을 만드는 대신, 혜니팩 생성 시점에 정책(`keep`, `replace`)을 `manifest.json`에 박제.
- **Cascading Rule**: 폴더별 기본 정책 + 파일별 예외 정책 지원 (사용자 요청: "config는 keep인데 특정 파일만 replace 가능하게").

---

### 6. 로직 통합 (Import = Update)

**사용자 통찰:**
> "혜니팩 내부에 정책이 함께 포함되게 되었으므로, 혜니팩 파일로 직접 import 하면서 기존 프로필을 업데이트할 때에도 동일한 정책 적용이 가능해질거 같네."

**AI 검증:**
- 기존 문서는 Import 시 하드코딩된 정책(`preserve`, `merge`)을 사용 중이었음.
- **개선**: Import와 Auto-Update가 모두 **Embedded Policy**를 따르도록 통일.
- **효과**: 수동 설치와 자동 업데이트가 완전히 동일한 결과를 보장.

---

### 7. 문서 작성 요청 및 초기 문제 (Gemini 3 Pro)

**사용자 요청:**
> "좋아 이대로 문서를 업데이트 하고 이번 대화 세션의 내용도 문서에 이어서 기록해서 업데이트 해줘."

**AI(Gemini 3 Pro) 작업:**
- 하이브리드 아키텍처를 반영한 `HYENIPACK_V2_AUTO_UPDATE.md` 작성 시도.
- `HYENIPACK_V2_DISCUSSION_SESSION.md`에 세션 3 요약 추가 시도.

**문제 발견: 내용 축약 및 UI 삭제**
- 사용자가 업데이트된 문서를 확인 후, 내용이 너무 축약되었고 기존 UI 디자인 세부사항(2-Column Layout, Tooltip 등)이 삭제되었음을 지적.

**사용자 피드백:**
> "대화 내용을 너무 축약했어. 내가 실제로 무슨 말을 썼는지, 니가 어떻게 판단해서 어떤 내용을 내게 보여줬는지 등을 조금 더 상세히 기록해줘.
> 그리고 기존 UI 아이디어나 너무 많은 데이터가 삭제됐는데? 이거 맞아?"

**재작업 시도:**
- AI(Gemini 3 Pro)가 상세한 Import UI (2-Column Layout, Tooltip 등) 복원 시도.
- Discussion log에 대화의 구체적인 인용문과 흐름 추가 시도.

---

### 8. 파일 업데이트 미반영 문제

**문제 발견: 변경사항이 실제로 반영되지 않음**
- AI가 문서를 수정했다고 보고했으나, 사용자가 확인한 결과 파일 내용이 실제로 변경되지 않음.

**사용자 피드백:**
> "뭘 수정한건지 모르겠네. 내가 보기엔 그대로인데?"

**재시도:**
- AI(Gemini 3 Pro)가 강제 덮어쓰기(`write_to_file` with `Overwrite: true`)로 재시도.
- 이번에는 성공적으로 파일이 업데이트됨.
- 그러나 여전히 내용이 사용자의 기대에 미치지 못함 (축약 문제 해결 안 됨).

---

### 9. 문서 리셋 및 모델 변경

**사용자 조치: 문서를 세션 2 버전으로 되돌림**
- 사용자가 Gemini 3 Pro의 작업물에 만족하지 못하고, 문서를 세션 2 버전(changes/ 있는 명령형 방식)으로 수동 복원.

**새로운 요청:**
> "수정한걸 다시 되돌렸어. 이번 대화 세션 끝에 업데이트된 설계 결론에 맞게 기존 문서를 업데이트 해줘."

**모델 변경:**
- 사용자가 모델을 Gemini 3 Pro에서 **Claude Sonnet 4.5 Thinking**으로 변경.

**AI(Claude Sonnet 4.5 Thinking) 재작성 성공:**
- 세션 3 하이브리드 아키텍처 결론을 반영하여 `HYENIPACK_V2_AUTO_UPDATE.md` 완전히 재작성.
- `HYENIPACK_V2_DISCUSSION_SESSION.md`도 상세한 대화 흐름 포함하여 업데이트.

**핵심 변경사항:**
- ❌ **제거**: `changes/` 디렉토리 (더 이상 불필요)
- ✅ **추가**: `overrides: OverridePolicy[]` (Embedded Policy)
- ✅ **통합**: Import = Update (동일한 로직)
- ✅ **보호**: 사용자 모드 보호 메커니즘 상세화
- ✅ **복원**: 상세한 Import UI (2-Column Layout, Tooltip 등)

---

### 10. 표현 개선 (Configs/기타 통합)

**사용자 질문:**
> "여기에서 config랑 기타는 사실 같은 방식인건데 표기만 이렇게 된거야? 아니면 서로 다른 방식을 쓰겠다는거야?"

**AI(Claude) 분석:**
- Configs와 기타 파일은 **완전히 같은 방식** (둘 다 `overrides` Embedded Policy 사용).
- 표에서 분리되어 있어 혼동을 유발함.

**수정:**
- 하이브리드 아키텍처 표를 통합하여 "Configs/기타"로 수정.

**개선 전:**
```
| **Mods** | 선언형 (Declarative) | ... |
| **Configs** | 명령형 (Imperative) | ... |
| **기타** | 내장 정책 | ... |
```

**개선 후:**
```
| **Mods** | 선언형 (Declarative) | ... |
| **Configs/기타** | 명령형 (Imperative) | Embedded Policy 기반 처리 |
```

---

### 11. 정책 동작 상세 설명 추가

**사용자 요청:**
> "keep, replace, merge가 정확하게 어떤 동작을 하는지 따로 설명이 필요해 보여. 
> 지금 보니까 merge와 keep이 폴더일 때 폴더 내부 파일들에 대해 어떻게 동작하는지 좀 헷갈려."

**핵심 혼동 포인트:**
- **파일**에 정책을 적용할 때 vs **폴더**에 정책을 적용할 때의 동작이 다름.
- 특히 `keep`과 `merge`가 폴더에 적용될 때 어떻게 동작하는지 불명확.
- `replace`를 폴더에 적용하면 통째로 교체되는지 확실하지 않음.

**AI(Claude) 추가 설명:**

**1. 파일 단위 정책 표 추가**:

| 정책 | 로컬에 파일 있음 | 로컬에 파일 없음 |
|------|----------------|----------------|
| **keep** | 건드리지 않음 (기존 유지) | 새 파일 설치 |
| **replace** | 덮어쓰기 | 새 파일 설치 |
| **merge** | 병합 시도* → 실패 시 덮어쓰기 | 새 파일 설치 |

*병합 가능 조건: JSON, Properties 등 구조화된 파일

**2. 폴더 단위 정책 표 추가** (핵심):

| 정책 | 동작 | 예시 |
|------|------|------|
| **keep** | 기존 파일 유지 + 새 파일만 추가 | `config/` 폴더에 keep 적용 시:<br/>- 기존: `a.json`, `b.json`<br/>- 신규: `b.json`, `c.json`<br/>→ 결과: `a.json`(유지), `b.json`(유지), `c.json`(추가) |
| **replace** | 폴더 통째로 교체<br/>(기존 파일 전체 삭제 후 재설치) | `config/` 폴더에 replace 적용 시:<br/>- 기존: `a.json`, `b.json`<br/>- 신규: `b.json`, `c.json`<br/>→ 결과: `a.json`(삭제), `b.json`(새로 설치), `c.json`(새로 설치) |
| **merge** | keep과 동일<br/>(기존 유지 + 신규 추가) | 폴더 병합 = 파일 additive 방식 |

**3. 실전 예시 추가**:

```json
{
  "overrides": [
    { "path": "config", "policy": "keep" },
    { "path": "config/sodium-options.json", "policy": "replace" },
    { "path": "scripts", "policy": "replace" }
  ]
}
```

**시나리오:**
- 로컬에 `config/options.txt`, `config/sodium-options.json`, `config/old-mod.json` 존재
- 혜니팩에 `config/sodium-options.json`, `config/new-mod.json` 포함
- 로컬에 `scripts/old-script.zs` 존재
- 혜니팩에 `scripts/new-script.zs` 포함

**결과:**
1. `config/`:
   - `options.txt` → 유지 (keep 정책)
   - `old-mod.json` → 유지 (keep 정책)
   - `sodium-options.json` → **덮어쓰기** (파일별 replace 정책이 더 구체적)
   - `new-mod.json` → 추가 (keep 정책)
2. `scripts/`:
   - `old-script.zs` → **삭제** (replace 정책)
   - `new-script.zs` → 설치 (replace 정책)

---

## 📊 최종 결정 사항

| 항목 | 기존 설계 (Imperative) | 변경된 설계 (Hybrid) |
|------|------------------------|----------------------|
| **핵심 로직** | `changes.json` 순차 실행 | Manifest 비교 (Diff) + 정책 적용 |
| **R2 구조** | `changes/` 폴더 필수 | `latest.json` + `.hyenipack` 만 존재 |
| **정책 정의** | 서버의 `changes.json` | 혜니팩 내부의 `manifest.json` |
| **제작 도구** | 복잡한 Diff/Migration 툴 | 런처 내보내기 UI (정책 선택) |
| **안정성** | 파일 유실 시 오류 가능 | 자가 치유 (Self-Healing) |
| **Import 로직** | 하드코딩된 정책 | Embedded Policy 기반 (Update와 동일) |
| **정책 표현** | - | Configs/기타 통합 (같은 메커니즘) |
| **정책 상세** | - | 파일/폴더 단위 동작 명확화 |

## 🚀 향후 계획
- **문서**: `HYENIPACK_V2_AUTO_UPDATE.md` 전면 개정 완료 (2025-12-02).
- **구현**: 하이브리드 로직(`syncMods`, `syncOverrides`) 및 Export UI(`PolicySelector`) 구현 필요.

---

## 📌 요약 (세션 3 - 12월 2일)

**세션 목표**: 하이브리드 아키텍처로 설계 전환 및 문서화  
**소요 시간**: 약 1.5시간  
**주요 성과**:
- ✅ 명령형 vs 선언형 논쟁 → 하이브리드 결론 도출
- ✅ Embedded Policy 아이디어 도입 (사용자 제안)
- ✅ Import = Update 로직 통일
- ✅ 사용자 모드 보호 메커니즘 확립
- ✅ 문서 전면 재작성 (UI 디테일 포함)
- ✅ 정책 동작 상세 설명 (파일/폴더 단위 구분)

**핵심 인사이트**:
1. **하이브리드의 가치**: "선언형의 안정성 + 명령형의 정밀함"을 동시에 달성.
2. **Embedded Policy**: 별도 도구 없이 Export 시점에 정책 결정 → 단일 진실 공급원.
3. **사용자 중심**: "사용자가 추가한 파일은 건드리지 않는다" 철학 관철.
4. **정확한 소통**: 표현의 모호함(Configs vs 기타, 정책 동작)을 제거하여 구현 오류 방지.

**다음 액션**: Phase 1 구현 시작 (설계 완전 확정)
